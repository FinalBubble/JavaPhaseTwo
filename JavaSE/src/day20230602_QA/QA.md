# 面试题解析
* 关于”对比“类型的面试题，建议回答时包括：
  * 多个对比项有什么相同/相似之处
  * 多个对比项的区别
  * 在应用中应该如何选取（重要）
  * 可能的话，加入一些扩展（对相关知识点的理解）
  
* 明确几个问题

  * 变量与对象是两个不同的概念

    * 假设由以下代码

    ```java
    `Object` a = new `Object`();
    ```

    * 以上代码中的a就是变量，在内存中实际存在的数据就是对象

  * 所有引用类型的变量值都是引用地址

    * 假设某对象在内存中的地址是`0x6528`，则变量的值就是`0x6528`
## `==` 与 `equals()`的区别
### `==` 与 `equals()`的区别
* `==` 是基本运算符，适用于所有类型的变量与变量的对比

* `equals()`是`Object`类定义的方法，由于`Object`类是`java`的基类（所有类的父类），所以，任何对象都可以调用`equals()`方法实现对比，但是，基本数据类型并不是对象，无法调用该对象实现对比

* `==` 对比的是变量的值
  * 如果是基本数据类型，对比的是字面值
  * 如果是引用数据类型，对比的是引用地址
  
  ```java
  int a = 100;
  int b = 100;
  int c = 200;
  System.out.println(a == b);//true
  System.out.println(a == c);//false
  Object d = new Object();
  Object e = new Object();
  Object f = d;
  System.out.println(d == e);//false
  System.out.println(d == f);//true
  ```

* `equals()`只是一个方法，到底返回`true`或`false`取决于方法的实现
  
  * 默认情况下（根据`Object`的定义），它与`==`的结果是相同的
  * `String`对`equals()`方法进行了重写
  
  ```java
  String a = new String("123");
  String b = new String("123");
  System.out.println(a == b);//false
  System.out.println(a.equals(b));//true
  ```

### 特殊情况

- 由于`java`对常量池的特殊处理，还有些特殊情况：

  - 直接声明的字符串使用`==`对比也是成立的

    ```java
    String  a= "123";
    String b = "123";
    System.out.println(a == b);//true
    ```

  - 使用`[-128,127]`区间值对整型包装类对象使用`==`对比也是成立的
  
  ```java
  Integer a = -129;
  Integer b = -129;
  System.out.println(a == b);//false
  
  a = -128;
  b = -128
  System.out.println(a == b);//true
  
  a = 127;
  b = 127;
  System.out.println(a == b);//true
  
  a = 128;
  b = 128
  System.out.println(a == b);//false
  ```

### 总结

- 相同之处：都是对比两个数据是否相同
- 不同之处：
  - `==`符号可以对比所有数据，而`equals()`只能被对象调用
  - `==`符号对比便变量的值是否相同，所以基本类型的变量只要字面值相同即返回`true`，引用类型的变量仅当引用地址相同时才返回会`true`；`equals()`方法是`Object`定义的，默认使用 `==`实现对比，所以，当该方法没有被重写时，执行效果与 `==` 相同，如果被重写，则取决于被重写的代码，以`String`为例，在执行`equals()`将逐一对比字符串中的每个字符，所以，只要两个`String`对象的字符完全相同，2个String对象使用`equals()`对比将会返回true
  - 补充说明：由于`java`会在编译器处理常量，并且，常量池中的每个常量都是唯一的，所以，当使用字符串常量直接对变量赋值，或使用[-128,127]区间值对`Byte/Short/Integer/Long`类型的对象赋值时，使用 `==` 对比的结果也是true
  - 实际应用原则：在实际编写代码时，对于基本数据类型的变量，必须使用 `==` 进行对比，因为基本数据类型不可以调用`equals()`方法；对于引用数据类型的变量，推荐使用`equals()`进行对比，并且，在有必要的情况下，重写`equals()`方法，使之返回结果的规则符合当前编写代码的需求，在重写时，至少保证同一个对象的对比结果为`true`（即：如果 `==` 对比为`true`，则`equals()`对比返回`true`）

## 什么是`hashCode`

### `hashCode()`的描述

- 返回该对象的哈希值。这个方法是为哈希表提供支持的，比如由`HashMap`提供的哈希表。
- `hashCode`的一般原则是:
- 在`java`应用程序的执行过程中，只要对同一个对象调用一次以上，`hashCode`方法就必须始终返回相同的整数，前提是在对象的equals比较中使用的信息没有被修改。对于同一个应用程序而言，某一次的执行与另一次执行时，该值不需要保持不一致。
- 如果两个对象根据`equals(Obiect)`方法对比的结果是相等的，那么在这两个对象上调用`hashCode`方法必须产生相同的整数结果。
- 有种情况并不是强制的: 如果根据`equals(iava.lang.Obiect)`方法，两个对象不相等，那么在这两个对象上调用`hashCode`方法必须产生不同的整数结果。然而，程序员应该知道，为不相等的对象产生不同的整数结果可能会提高哈希表的性能。

## 常见的误区

- 误区：`hashCode`就是对象的内存地址
  - 解读：哈希（`hash`）一般指散列算法，也称之为哈希算法，在`Object`类的实现中，哈希码（`hashCode`）是通过哈希算法得到的一个整型结果，本质上与内存地址没有关系
  - 误区产生原因：根据`Object`类的`hashCode()`实现，每个对象的`hashCode`值（理论上）都不同，通常可以用于判断`2`个变量是否引用同`1`个对象
  - 反向论证：`hashCode`无法表示对象的内存地址
    - `JVM`在进行垃圾管理时，会移动对象的位置，即：经过某次垃圾回收，对象在内存中的位置可能就已经发生了变化，但`hashCode`值并不会变
    - `Integer`（或int）`类型`的值区间是`-2147483648~2147483647`，`java`管理的内存已经超过`4GB`，所以`hashCode`不可能是内存地址
      - $2\times1024\times1024\times1024$即`2GB`
      - $2\times1024\times1024\times1024-1 = 2147483647$
- 误区：手动使用`hashCode`
  - 解读：如同`java` SE文档中指出的`”This method is supported for the benefit of hash tables such as those provided by HashMap“`，即：这个方法是为哈希表提供支持的，比如由`HashMap`提供的哈希表
    - 通俗来讲，`hashCode`的设计是提供给`JVM`管理对象时使用的，并不是让开发者自行使用的

### `hashCode`的作用

- `Hash`容器可以通过`hashCode`定位需要使用的对象
  - 典型的`Hash`容器：`HashSet`、`hashMap`、`hashTable`、`ConcurrentHashMap`
  - 再次强调：`hashCode`不是对象的内存地址
- `Hash`容器通过`hashCode`来排除两个不相同的对象
  - 例如，向`HashSet`的元素、`HashMap`的`Key`等都要求”唯一“，如果即将添加的元素的`hashCode`与集合中已有的每个元素的`hashCode`均不同，则可视为”当前集合中尚不存在即将添加的元素“
  - 如果`2`个对象的`hashCode`相同，`Hash`容器还会调用`equals()`方法，仅当`equals()`也返回`true`时，才会视为”相同“

### 总结

- `hashCode()`是`Object`定义的方法，它将返回一个整型值，它并不代表对象在内存中的地址，它存在的价值是为`Hash`容器处理数据时提供支持，`Hash`容器可以根据`hashCode`定位需要使用的对象，也可以根据`hashCode`来排除2个不相同的对象，即：`hashCode`不同，则视为`2`个对象不同
- 在重写`hashCode()`时，应该遵循`javaSE`的官方指导：
  - 如果`2`个对象使用`equals()`对比的结果为`true`，则这`2`个对象的`hashCode()`返回的结果应该相同
  - 如果`2`个对象使用`equals()`对比的结果为`false`，则这`2`个对象的`hashCode()`返回的结果应该不同
  - 通常，你不必关系如何重写`equals()`方法和`hashCode()`方法，而是使用`IDE`生成，例如`Eclipse`、`IntelliJ IDEA`，它们生成的方法时符合以上指导意见的

## `String`、`StringBuffer`和`StringBuilder`的区别

### `String`、`StringBuffer`和`StringBuilder`的共同点

- 都是用于处理字符串数据的类
- 都是管理内部的一个`char[]`实现的
- 实现的接口大致相同，特别是`CharSequence`接口
  - 许多`API`的设计中，方法啊的参数或返回值都使用这个接口，使得参数或返回值更加灵活
- 有许多相同的`API`，例如`replace()`，`indexOf()`等

### `String`、`StringBuffer`和`StringBuilder`的区别

- `String`的“不可变”特性：每个字符串对象都是不可变的

  ```java
  String s = "hello";
  s = "hello,world!";
  ```

- 以上代码中，声明了`1`个变量，创建了`2`个对象

- `String`的“不可变”特性是由于其内部通过管理一个`char[]`决定的

  - 在`java`语言中，数组在内存必须是连续的，则其长度不可变

- `String`的“不可变”特性与该类声明中的`final`无关

- 因为`String`的“不可变”特性，在`String`的`API`中，所有修改字符串的方法都将返回新的`String`对象

- 基于`String`的“不可变”特性，`String`的修改操作的效率将非常低下

  - 需要寻址、创建新对象，还可能将原有`char[]`的某部分复制到新的`char[]`中

- `StringBuffer`和`StringBuilder`从一开始就会使用长度更长的`char[]`，哪怕只用于存放少量的几个字符

  - 其`length()`方法会返回实际存放的字符数量

- 在许多调整字符串的操作中，`StringBuffer`和`StringBuilder`只需要直接调整内部的`char[]`即可，不需要频繁的寻址、创建新对象等操作，所以，实际执行效率原高于String类

  - 如果默认的`char[]`长度（实际长度）不满足运算需求时，会自动扩容，也需要创建新的对象

- `StringBuffer`是线程安全的，`StringBuilder`不是

### 总结

- 都是用于处理字符串数据的类
- 都是管理内部的一个`char[]`实现的
- 实现的接口大致相同，特别是`CharSequence`接口
- 有许多相同的`API`，例如`replace()`，`indexOf()`等
- 实际使用原则
- 不同之处:
  - `String`的字符串操作效率低下，是因为它的“不可变”特性决定的
  - `StringBuffer`和`StringBuiler`会保证管理的`char[]`的长度始终高于实际存入的字符长度，在处理字符串操作时，效率远高
  - `StringStringBuffer`是线程安全的，而`StringBuilder`不是
- 实际使用原则: 尽管`StringBuffer`和`StringBuilder`在处理字符串时的效率远高于`String`，但并不是每个`String`都需要频繁的改变，相比之下，使用`String`的语法更加简洁、直观，实际占用的存储空间更小，所以，当字符串不需要频繁的改变时优先使用`String`。如果字符串需要频繁改变，原则上来说，仅当单线程运行时，或已经采取措施保障线程安全时，优先使用`StringBuilder`，因为它的执行效率高于`StringBuffer`，事实上，尽管`StringBuilder`的执行效率比`StringBuffer`高，但差距并不大，为了避免后续调整带来的安全隐患，当字符串可能频繁改变时，一般使用`StringBuffer`

## `ArrayList`与`LinkedList`的区别

### `ArrayList`与`LinkedList`的共同点

- 关于“序列的”
  - 在List集合中的个元素都有索引，类似数组下标，是顺序编号的
  - 不推荐描述为“有序的”，详见后续`LinkedList`的存储结构
  - 同理，不要将`Set`集合描述为“无序的”，只能描述为“散列的”，例如`TreeSet`、`LinkedHashSet`的个元素就可以表现出“有序”的特征
- 关于“存储相同元素”：
  - 在使用集合时，仅当`2`个对象的`hashCode()`返回值相同，且`equals()`对比结果为`true`时，视为“相同”
    - `Set`集合不可以存储相同的元素

### 错误的表达

- 错误的表达：当需要查询时，使用`ArrayList`；当需要修改时，使用`LinkedList`
- 解读：
  - 尽管`ArrayList`易读难写，但是，没有写入数据，则无从读起
  - 尽管`LinkedList`易写难读，但是，光写入，不读取，没有任何意义
  - `ArrayList`和`LinkedList`这两者之间没有继承关系，不可互相转换
  - 该“错误的表达”是因为描述不精准

### 关于存储空间与执行效率

- 目前主流的计算机或服务器的性能均非常优秀，无论是运行速度还是存储容量都非常高，在不结合实际情况时，单纯的讨论存储空间或执行效率没有任何意义
  - 例如：有`10`万个`“hello,world!”`在内存中没有销毁，形成了浪费，将无谓的占用内存中 ~$12 \times 12 \times10000 = 2400000$字节，约`2.3`MB内存
    - 如果是单机应用，或访问频率非常低的服务器端应用，负面影响并不明显
    - 如果是访问频率非常高的服务端应用，负面影响价格非常明显
- 如果对程序的运行效率的要求非常高，可以事先分析读写频率，并根据分析结果使用`ArrayList`或`LinkedList`
  - 所以，此前分析的“误区”在于描述不精准，大致方向并没有问题

### `ArrayList`与`LinkedList`的区别

- `ArrayList`的底层实现是基于数组的
  - 优点：查询效率高
  - 缺点：修改效率低
- `LinkedList`的底层实现是基于双向链表的
  - 内部使用“节点”管理元素
  - 优点：修改效率高

- 因为`LinkedList`的底层实现基于双向链表，当添加元素时，本质是基于新元素创建“节点”，每个节点需要记录只想前一个结点和后一个节点的引用，占用的存储空间更多

### 扩展

- 无论是`ArrayList`，还是`LinkedList`，都是线程不安全的，当在多线程中需要使用`List`时，应该使用`CopyOnWriteArrayList`

### 总结

- 相同之处：
  - 都是`List`接口的实现类
    - 都是序列的，可存储相同元素
    - 绝大部分情况下，不关心特有方法
  - 都是线程不安全的
- 不同之处：
  - `ArrayList`的底层实现是基于数组的，所以，查询效率高，但修改效率偏低
  - `LinkedList`的底层实现是基于双向链表，所以，查询效率偏低，但修改效率高，另外，其内部本质上管理的是多个节点，每个节点需要记录指向前一个节点和后一个节点的引用，占用的内存空间更多
- 实际使用原则:在使用简单的字符串作为集合元素时，在`10`万级别的元素数量时,`ArrayList`和`LinkedList`的性能差异并不明显(在绝大部分情况下，使用List时的元素数量都不超过`100`个，尽管元素数据更加复杂)，并且，不可以单纯的只读不写，或只写不读，同时，基于`ArrayList`占用的存储空间更少，一般使用`ArrayList`即可，仅当需要极致的追求性能时，再根据读写频率来区分使用，但是当需要考虑线程安全问题时，则使用`CopyOnWriteArrayList`

## 什么是`volatile`

### 什么是`volatile`

- `volatile`是`java`语言中的一个关键字，可以修饰类的属性

  - 其英文释义一般是：不稳定的

  ```java
  public class VolatileDemo{
  	public volatile int i;
  }
  ```

### `volatile`的主要作用

- `volatile`的主要作用有：
  - 禁止指令重排
  - 确保多线程时属性的可见性

### 关于指令重排

- 在代码没有依赖关系的前提下，出于优化的目的，`CPU`和编译器均可能会对指令进行重新弄排序，可能导致执行顺序与源代码顺序并不相同

  ```java
  // 以下2行代码的执行先后顺序可以被改变，并且不会出现任何错误
  int x = 5;
  int y = 8;
  //以下2行代码的执行先后顺序不会被改变
  int a = 5;
  int b = a + 8;
  ```

- ，但是，在多线程下，指令重排可能导致运行结果不符合预期

  ```java
  //多线程共享变量
  public static boolean flag;
  public static int x;
  ```

  ```java
  //线程x
  public synchronized void run(){//语句1
      if (flag) {
          x += 100;
      } else {
          x += 200;
      }
      System.out.println(x);
  }
  ```

  ```java
  //线程y
  public void run(){
      x = 1;  //语句2
      flag = true; //语句3
  }
  ```

  语句`1`、`2`、`3`的顺序不同，会导致结果不同，即：`x`的输出值不同

- 指令重排时`CPU`和编译器决定的，一定程度上人为不可控

- 指令重排的目的是优化指令，提高执行效率，在单线程中，执行结果不会出现问题，但是，在多线程中，可能出现预期外的结果，所以，应该为共享变量添加`volatile`关键字进行修饰

### 关于属性的可见性

- 每个线程在执行过程中，有专属的工作内存空间，当需要某个值时，会优先从工作内存中查找，如果工作内存中没有，则会从主存中将值复制到工作内存中并缓存

- 在多线程情境下，可能存在：`X`线程已经将值缓存到工作内存中，`Y`线程改变了主内存的值，但`X`线程仍使用工作内存中缓存的值（尚未从主内存中同步最新的值）

- 以下代码中，主线程无法停止子线程

  ```java
  public static boolean isRunnng;//子线程循环变量
  public static void main(String[] args) throws InterruptedException{
      isRunning = true;//主线程：将子线程循环变量设置为true
      new Thread(){
          public void run(){
              while(isRunning){} //子线程：死循环
          }
      }.start(); //主线程：开启子线程，将进入死循环
      Thread.sleep(1000);//主线程：休眠1秒
      isRunning = false;//主线程：将子线程循环变量设置为false
      System.out.println("主线程已将循环变量设置为false，主线程运行结束！");
  }
  ```

- 添加`volatile`可改变这个问题

- 在多线程中，由于各线程会优先从工作内存中获取共享变量的值，可能导致某线程更新了共享变量的值，但其他线程仍使用工作内存中缓存的值，出现属性可见性问题，添加`volatile`解决此问题

### 常见的误区

- 误区：使用`synchronized`后不需要使用`volatile`
- 解读：两者都是用于解决多线程相关问题的，但问题的情景并不相同，通常，使用`synchronized`解决的问题大多是“多个线程执行相同的代码”的情景，而使用`volatile`解决的问题大多是，“多个线程执行的代码不同，但使用到了相同的共享变量的情景”

### 总结

- 关于`volatile`：
  - 它是一个关键字，用于修饰类的成员属性
  - 它的主要作用有：
    - 禁止指令重排
    - 确保多线程时属性的可见性
- `synchronized`和`volatile`均不可替代彼此，虽然两者都是用于解决多线程相关问题的，但问题的情景并不相同，通常，使用`synchronized`解决的问题大多是“多个线程执行相同的代码”的情景，而使用`volatile`解决的问题大多是，“多个线程执行的代码不同，但使用到了相同的共享变量的情景”
- 实际使用原则：当某个属性出现在多个方法中，至少有1个方法会改变该属性的值，且这些方法可能同时被不同的线程执行，则应该为属性添加`volatile`关键字

## `Thread`类中的`start()`和run()方法的区别

### 关于`Thread`类的`start()`方法

官方说明翻译：

- 导致该线程开始执行
- 在该线程中`JVM`会调用`run()`方法，结果时`2`个线程会同步执行：当前线程（执行`start()`方法的）和另一个线程（执行`run(）`方法的）
- 一个线程启动超过`1`次以上时不合法的
- 通常，当一个线程执行完毕后，不可以再次启动

通俗解释：

- 是用于启动线程的方法
- 其内部会（自动）调用`run()`方法
- 通常，每个线程对象只能调用1次该方法

## 关于`Thread`类的`run()`方法

官方说明翻译：

- 如果这个线程时使用一个独立的`Runnable`对象构建的，那么，那个`Runnable`对象的`run()`方法会被调用；否则，这个方法什么都不知晓，也不会返回任何值
- `Thread`的子类应该重写这个方法

通俗解释：

- 是在线程启动后（自动的）被调用的方法
- 用于编写子线程执行的代码
- 默认的`run()`方法会尝试调用`Runnable`对象（如果存在的话）的`run()`方法，否则，什么都不执行，也不返回任何值
  - 如果你创建线程对象时使用`Runnable`对象作为构造方法的参数，当线程启动时会调用`Runnable`对象的`run`()方法
    - 所以，你应该在`Runnable`实现类中实现`run()`方法
  - 如果你创建的是`Thread`子类的对象，则应该在`Thread`子类中重写`run`()方法

### 常见的误区

- 误区：`Runnable`是线程接口
  - 解读：`Runnable`表示”可执行的“，创建`Thread`对象时，可以使用`Runnable`接口类型的对象作为构造方法的参数，并且，在子线程中执行的确实是`Runnable`实现类中的`run()`方法，但是，`Runnable`自身并不是线程接口，事实上，还有许多其它类都可能使用到`Runnable`，但与线程完全没有关系

### 总结

- 关于`start()`方法：
  - 是用于启动线程的方法
  - 其内部会（自动）调用`run()`方法
  - 通常，每个线程对象只能调用1次该方法
- 关于`run()`方法：
  - 是在线程启动后（自动的）被调用的方法
  - 用于编写子线程执行的代码
  - 默认的`run()`方法会尝试调用`Runnable`对象（如果存在的话）的`run()`方法，否则，什么都不执行，也不返回任何值
    - 使用`Runnable`接口时，应该实现`run()`方法
    - 使用`Thread`子类时，应该重写`run()`方法
